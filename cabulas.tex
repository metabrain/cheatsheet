\documentclass[]{article}

\usepackage[utf8]{inputenc}

%\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[disable]{todonotes}

\renewcommand{\mint}{\inputminted[
	mathescape,
	tabsize=3
	%,linenos
	%,frame=lines
]}

\title{{\bf Informatik-Algorithmen - Caparica Chaputa}%  \\\includegraphics[scale=0.50]{solo_mid.png}}
		\\ {\large Faculdade de Ciências e Tecnologia da Universidade Nova de Lisboa}}
\author{{\bf Daniel Parreira}
		\and Eduardo Marques
		\and Pedro Borges}

\begin{document}

\maketitle

\tableofcontents

\listoftodos

\section{Miscelaneous}

\subsection{Notes}
1 - Verify program limits regarding the data type (is \texttt{int} enough? or \texttt{long}?)\\
2 - Verify possible problems with precision

\subsection{Limits}
\begin{tabular}{l c r}
\hline
& Maximum & Minimum \\
\hline
long & 9223372036854775807 & -9223372036854775808 \\
\hline
int & 2147483647 & -2147483648 \\
\hline
\end{tabular}

\subsection{Fast I/O}
\mint{java}{fastio.java}

\clearpage

%%%%%%%%%%%%%

\section{Searching}

\subsection{Median - Minimizing the average of the absolute deviations}
\mint{java}{median.java}

\subsection{Binary search}
\mint{java}{binarysearch.java}

\subsection{Ternary search - Finding the maxi/minimum of a (monotone) function}
\mint{python}{ternary.py}

\subsection{Backtracking using DFS}
\mint{java}{dfsbacktraking.java}

\subsection{A*}
\mint{java}{astar.java}

\clearpage

%%%%%%%%%%%%%

\section{Number Theory}

\subsection{Combinations}
\todo[inline]{Fazer e testar código em Java de $C^n_k$}
\mint{java}{combinacoes.java}

\subsection{Arranges (without repetition)}
\todo[inline]{Fazer e testar código em Java de $A^n_k$}
\mint{java}{arranjos.java}


\subsection{Greatest Common Divisor}
\mint{java}{gcd.java}

\subsection{Least common multiple}
$lcm(a,b) = ab / gcd(a,b)$

\subsection{Equação Diofantina Linear}
1) Existe uma solução para $ax + by = c$, se $d = mdc(a,b)$ divide $c$\\
2) Se $d | c$, então determinando o $u$ e $v$ de  $ua + vb = d$, consegue-se encontrar uma solução se atribuirmos \\
\begin{center}
$x_0 = uc/d$ and $y_0 = vc/d$
\end{center}
Sendo todas as outras soluções dadas por \\
\begin{center}
$x = x_0 + (b/d) t$, $y = y_0 - (a/d)*t$ para $t \in \mathbb{Z}$
\end{center}

\subsection{Linear congruency}
\mint{java}{mod.java}

\subsection{Sieve of Erastóstenes}
\mint{java}{sieve.java}

\subsection{Fibonacci Numbers}
\mint{java}{fibonacci.java}

\subsection{Propriedades de Matrizes}
{\large
$$ A^1 + ... + A^{n-1} + A^n  = 
 ( A^1 + ... + A^{n/2} ) + A^{\frac{n}{2}} . ( A^1 + ... + A^{\frac{n}{2}} ) $$
}

\subsection{Prime Factorization}
\todo[inline]{prime factorization}
\todo[inline]{Mais formulas de matrizes?}
\todo[inline]{Probabilidades?}
\todo[inline]{Triangulo de Pascal?}
\todo[inline]{Geometria?}
\todo[inline]{Flood-fill}

\clearpage

%%%%%%%%%%%%%

\section{Dynamic Programming}
\subsection{Unbounded Knapsack}
$$m[0] = 0$$
$$m[w] = max_{w_i \leq w}(v_i + m[w - w_i])$$
\todo[inline]{Find unbounded Knapsack problem and post here the JAVA code}

\subsection{Knapsack 0-1}
\mint{java}{knapsack_0_1.java}

\clearpage

%%%%%%%%%%%%%

\section{Graphs}

\subsection{Minimum Spanning Tree}
\subsubsection{Kruskal (when more vertices than edges)}
\mint{java}{kruskal.java}
\subsubsection{Prim (when more edges than vertices)}
\mint{java}{prim.java}

\subsection{Disjoint-set (Union Find)}
\mint{java}{unionfind.java}

\subsection{Depth First Search (Breadth with Queue instead of Stack)}
\mint{java}{dfs.java}

\subsection{Shortest Paths from A}
\subsubsection{Dijkstra (no negative-edges)}
\mint{java}{dijkstra.java}
\subsubsection{Bellman Ford (detects negative cycles)}
\mint{java}{bellman-ford.java}

\subsection{All-Pairs Shortest Paths - Floyd-Warshall (no negative-cost cycles)}
\mint{java}{floyd-warshall.java}

\subsection{Max Flow - Edmonds-Karp}
\mint{java}{edmonds-karp.java}

\subsection{Topological Sort}
\mint{java}{topological_sort.java}

\subsection{Strongly Connected Components - Tarjan}
\mint{java}{tarjan.java}

\subsection{Articulation}
\mint{java}{articulation.java}

\clearpage
%%%%%%%%%%%%%%%

\section{Sorting algorithms}

\subsection{MergeSort}
\mint{java}{mergesort.java}

\subsection{QuickSort}
\mint{java}{quicksort.java}

\clearpage
%%%%%%%%%%%%%%%%

\section{Computational Geometry}

\subsection{Line equations}
$$Ax+By=\alpha$$
\begin{itemize}
\item if $Ax+By=0$, intersected
\item if $Ax+By>0$, above
\item if $Ax+By<0$, under
\end{itemize}

\subsection{Closest Pairs in 2D - Quad Tree}
\mint{java}{quadtree.java}

\clearpage
%%%%%%%%%%%%%%%%

\section{Databases}

\textbf{Principle of transaction} - sequence of successive DB operations that transform a database from a consistent state into another consistent state from BOT to EOT (Commit/Abort)
\begin{itemize}
\item ACID - Atomicity, Consistency, Isolation and Durability.
\item A transaction will always come to an end.
\item Normal (commit): changes are permanently stored within the DB.
\item Abnormal (abort/rollback): already composed changes are taken back.
\end{itemize}

\textbf{Determine Serializability} - A schedule is serializable, IFF its precedence graph of commited transactions is acyclic. Determine all serializable schedules by topological sorting.

\textbf{Deadlocks} - arise from cycling waiting dependencies between two or more transactions.

\textbf{Lock-based/Pessimistic Synchronization} - use 2PL (acquire all then release all) on data objects used.
\begin{itemize}
\item Timeout, abort one of the transactions and then repeat it.
\item Deadlock prevention - avoid deadlocks from the onset (not practicable in DBS)
\item Deadlock avoidance - runtime support to detect potential deadlocks before they happen
\item Deadlock detection - Runtime wait-for graph and cycle search for the detection of deadlocks and removal of those found by aborting one or several TAs that participate in the cycle until the deadlock is avoided.
\end{itemize}

\textbf{Lock-free/Optimistic Synchronization} - after transaction is processed, \textbf{validate} it. If no conflicts occurred during the transaction, commit the write set. Else, abort.
\begin{itemize}
\item Low risk of conflicts provide good performance (typical scenario in DBS).
\item No deadlocks.
\item Potentially more concurrent than the lock-based alternative.
\item Might not be fair (starving a TA).
\item Readset and writeset have to be kept for each transaction, more overhead.
\end{itemize}

\textbf{SQL Consistency Levels} - tradeoff between performance and consistency.
\begin{itemize}
\item 3 = SERIALIZABLE (best, but has more deadlocks because of long write/read locks)
\item 2 = REPEATABLE READ (non-repeatabler read possible)
\item 1 = READ COMMITTED (dirty-reads/lost updates possible)
\item 0 = READ UNCOMMITTED (short write locks, "chaos")
\end{itemize}

\subsection{SQL commands (IBM db2)}
\mint{sql}{db2.sql}

\clearpage
%%%%%%%%%%%%%%%%

\section{Networking}



\end{document}
